/*
 * Given a mesh, randomly select electrodes (without replacement) from the desired layers, and write out
 * the electrode indices to a file.
 */

#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/smart_ptr.hpp>
#include <getfem/getfem_mesh.h>
#include <sloc/material_data.h>

using namespace std;
using namespace boost::algorithm;

typedef unsigned int id;
typedef map<id,id> map_layers_t;

typedef set<id> set_t;
typedef boost::shared_ptr<set_t> shared_set_t;
typedef map<id,shared_set_t> map_id_set_t;

typedef vector<id> vector_t;
typedef boost::shared_ptr<vector_t> shared_vector_t;
typedef map<id,shared_vector_t> map_id_vector_t;

// ----------------------------------------------------------------------------

bool split_layer_num(string str, unsigned int &layer, unsigned int &num)
{
    vector<string> pair;
    boost::algorithm::split(pair, str, is_any_of("/:"), token_compress_on);

    if (pair.size() != 2)
        return false;

    try {
        layer = boost::lexical_cast<unsigned int>(pair[0]);
        num = boost::lexical_cast<unsigned int>(pair[1]);
    } catch (boost::bad_lexical_cast &) {
        return false;
    }

    return true;
}

void write_vtk_points(string filename, getfem::mesh& mesh, map_id_vector_t& nodemap)
{
    int i;
    int npts = 0;

    // how many points do we have?
    for (map_id_vector_t::iterator it = nodemap.begin(); it != nodemap.end(); ++it)
        npts += it->second->size();

    // write out the vtk file
    ofstream out;
    out.open(filename.c_str());
    cout << "Writing vtk file '" << filename << "'" << endl;

    // header
    out << "# vtk DataFile Version 2.0" << endl
        << "Location of electrodes generated by select_electrodes" << endl
        << "ASCII" << endl
        << "DATASET UNSTRUCTURED_GRID" << endl;

    // points
    out << "POINTS " << npts << " float" << endl;
    for (map_id_vector_t::iterator it = nodemap.begin(); it != nodemap.end(); ++it)
    {
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
        {
            const unsigned int n = *vit;
            bgeot::base_node point = mesh.points()[n];
            out << point[0] << " " << point[1] << " " << point[2] << endl;
        }
    }

    // cells
    const int ncells = npts;
    const int size = ncells + 1*ncells;
    out << "CELLS " << ncells << " " << size << endl;
    for (i = 0; i < ncells; i++)
        out << "1 " << i << endl;

    // cell types
    const int VTK_VERTEX = 1;
    out << "CELL_TYPES " << ncells << endl;
    for (i = 0; i < ncells; i++)
        out << VTK_VERTEX << endl;

    // data
    out << "POINT_DATA " << npts << endl;
    out << "SCALARS node_id int 1" << endl;
    out << "LOOKUP_TABLE default" << endl;
    for (map_id_vector_t::iterator it = nodemap.begin(); it != nodemap.end(); ++it)
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
            out << *vit << endl;

    // done
    out.close();
}

// ----------------------------------------------------------------------------

void usage(const char *pgm)
{
    cerr << "Usage: " << pgm
         << " -m meshfile -i matfile [-v vtkfile] -o outfile layer1/count1 layer2/count2 ..."
         << endl;
    exit(1);
}

void process_args(int argc, char *argv[], string& meshfile, string& matfile, string& vtkfile, string& outfile, map_layers_t& layers)
{
    char *pgm = argv[0];

    if (argc == 1)
        usage(pgm);

    meshfile = "";
    vtkfile = "";
    outfile = "";
    layers.clear();

    while (argc > 1)
    {
        if (strncmp(argv[1], "-m", 3) == 0)
        {
            // read the next argument (expecting meshfile)
            argc--; argv++;
            if (argc > 1)
                meshfile = argv[1];
            else
                break;
        }
        else if (strncmp(argv[1], "-i", 3) == 0)
        {
            // read the next argument (expecting matfile)
            argc--; argv++;
            if (argc > 1)
                matfile = argv[1];
            else
                break;
        }
        else if (strncmp(argv[1], "-v", 3) == 0)
        {
            // read the next argument (expecting vtkfile)
            argc--; argv++;
            if (argc > 1)
                vtkfile = argv[1];
            else
                break;
        }
        else if (strncmp(argv[1], "-o", 3) == 0)
        {
            // read the next argument (expecting outfile)
            argc--; argv++;
            if (argc > 1)
                outfile = argv[1];
            else
                break;
        }
        else
        {
            // assume it's a layer string
            unsigned int mat, num;
            bool valid = split_layer_num(argv[1], mat, num);

            if (!valid)
            {
                cerr << "Invalid layer count '" << argv[1] << "'" << endl;
                usage(pgm);
            }

            if (layers.count(mat) > 0)
            {
                cerr << "Duplicate layer specified: '" << argv[1] << "'" << endl;
                usage(pgm);
            }

            layers[mat] = num;
        }

        // advance to the next argument
        argc--; argv++;
    }

    if (meshfile.empty())
    {
        cerr << "Missing mesh file!" << endl;
        usage(pgm);
    }

    if (outfile.empty())
    {
        cerr << "Missing output file!" << endl;
        usage(pgm);
    }

    if (layers.empty())
    {
        cerr << "No layers selected!" << endl;
        usage(pgm);
    }
}

// ----------------------------------------------------------------------------

int main(int argc, char *argv[])
{
    int i,j;
    unsigned int mat, num;
    unsigned int total_num;

    // process cli args
    string meshfile, matfile;
    string vtkfile, outfile;
    map_layers_t layers;
    process_args(argc, argv, meshfile, matfile, vtkfile, outfile, layers);

    // read the mesh
    getfem::mesh mesh;
    cout << "Reading mesh '" << meshfile << "'" << endl;
    mesh.read_from_file(meshfile.c_str());

    // read the mesh materials
    sloc::MaterialData material_data;
    cout << "Reading mesh materials '" << matfile << "'" << endl;
    material_data.read_materials(matfile.c_str());

    // only cells are associated with materials, but we want an association
    // between nodes and material ids. so, we need to walk through each of the
    // cell's nodes and build a map from material ids to its set of nodes
    map_id_set_t nodes_by_mat;
    for (i = 0; i < mesh.nb_convex(); i++)
    {
        const int cell_mat_id = material_data.get_material_id(i);

        if (layers.count(cell_mat_id) > 0)
        {
            if (nodes_by_mat.count(cell_mat_id) == 0)
                nodes_by_mat[cell_mat_id] = shared_set_t(new set_t);

            getfem::mesh::ind_cv_ct pts = mesh.ind_points_of_convex(i);
            for (getfem::mesh::ind_cv_ct::const_iterator it = pts.begin(); it != pts.end(); ++it)
                nodes_by_mat[cell_mat_id]->insert(*it);
        }
    }

    // add up the layer counts
    // (1) only add counts whose layers that are present in the mesh file
    // (2) if desired count is larger than the number of actual nodes in the mesh
    //     by that material id, then use the actual number as the cutoff value
    total_num = 0;
    for (map_layers_t::iterator it = layers.begin(); it != layers.end(); ++it)
    {
        mat = it->first;
        num = it->second;
        if (nodes_by_mat.count(mat) > 0)
        {
            if (num > nodes_by_mat[mat]->size())
                it->second = nodes_by_mat[mat]->size();
            total_num += it->second;
        }
    }

    // now that duplicates are removed, let's copy the sets of nodes
    // into corresponding vectors, so we can shuffle them later
    map_id_vector_t nodes;
    for (map_id_set_t::iterator it = nodes_by_mat.begin(); it != nodes_by_mat.end(); ++it)
    {
        mat = it->first;

        if (nodes.count(mat) == 0)
            nodes[mat] = shared_vector_t(new vector_t);

        for (set_t::iterator sit = it->second->begin(); sit != it->second->end(); ++sit)
            nodes[mat]->push_back(*sit);
    }
    nodes_by_mat.clear();

    // shuffle each of the vectors of nodes and copy the first num elements
    srand(time(NULL));
    map_id_vector_t random_nodes;
    for (map_id_vector_t::iterator it = nodes.begin(); it != nodes.end(); ++it)
    {
        unsigned int mat = it->first;
        unsigned int num = layers[mat];

        //cout << "shuffling layer " << mat << endl;
        random_shuffle(it->second->begin(), it->second->end());

        if (random_nodes.count(mat) == 0)
            random_nodes[mat] = shared_vector_t(new vector_t);

        // copy the first num entries in shuffled vector
        cout << "Taking " << num << " random nodes from layer " << mat << endl;
        unsigned count = 0;
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
        {
            random_nodes[mat]->push_back(*vit);
            if (++count >= num) break;
        }
    }
    nodes.clear();

    // write out the vtk file
    if (!vtkfile.empty())
        write_vtk_points(vtkfile, mesh, random_nodes);

    // write out the electrodes file
    ofstream out;
    out.open(outfile.c_str());
    cout << "Writing " << total_num << " electrodes to '" << outfile << "'" << endl;
    for (map_id_vector_t::iterator it = random_nodes.begin(); it != random_nodes.end(); ++it)
    {
        mat = it->first;
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
        {
            const unsigned int node_id = *vit;
            out << node_id << endl;
        }
    }
    out.close();

    return 0;
}
