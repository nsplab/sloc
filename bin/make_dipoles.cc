/*
 * Write out a dipoles file suitable for use in the bem_forward_solver.
 */

#include <string>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <boost/program_options.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/lexical_cast.hpp>
#include <sloc/dipole_sources.h>

using namespace std;
using boost::split;
using boost::is_any_of;
using boost::token_compress_on;
using boost::lexical_cast;

namespace po = boost::program_options;

typedef vector<string> strings;

void read_dipole_from_str(sloc::DipoleSources &dipole_sources, const std::string& s)
{
    stringstream ss;
    ss << "Expecting format x,y,z/px,py,pz but got '" << s << "'";
    std::invalid_argument exc(ss.str());

    strings xps;
    split(xps, s, is_any_of("/"), token_compress_on);

    if (xps.size() != 2)
        throw exc;

    strings xs, ps;
    split(xs, xps[0], is_any_of(","), token_compress_on);
    split(ps, xps[1], is_any_of(","), token_compress_on);

    if ((xs.size() != 3) || (ps.size() != 3))
        throw exc;

    try
    {
        double x,y,z;
        x = boost::lexical_cast<double>(xs[0]);
        y = boost::lexical_cast<double>(xs[1]);
        z = boost::lexical_cast<double>(xs[2]);

        double px,py,pz;
        px = boost::lexical_cast<double>(ps[0]);
        py = boost::lexical_cast<double>(ps[1]);
        pz = boost::lexical_cast<double>(ps[2]);

        dipole_sources.add_source(dealii::Point<3>(x,y,z), dealii::Point<3>(px,py,pz));

        if (true)
        {
            cout << "Creating dipole at x="
                 << x << "," << y << "," << z << " with p="
                 << px << "," << py << "," << pz << endl;
        }
    }
    catch (boost::bad_lexical_cast &)
    {
        throw exc;
    }
}

// XXX: move this function into DipoleSources as .write_vtk()
void write_vtk_dipoles(sloc::DipoleSources &dipole_sources, const char *filename)
{
    unsigned int npts = dipole_sources.n_sources();
    unsigned int i;

    if (npts == 0)
        return;

    ofstream out;
    out.open(filename);

    // header
    out << "# vtk DataFile Version 2.0" << endl
        << "Dipole sources generated by make_dipoles" << endl
        << "ASCII" << endl
        << "DATASET UNSTRUCTURED_GRID" << endl;

    // points
    out << "POINTS " << npts << " float" << endl;
    for (i = 0; i < npts; ++i)
    {
        const sloc::DipoleSource ds = dipole_sources(i);
        dealii::Point<3> x = ds.location;
        out << x[0] << " " << x[1] << " " << x[2] << endl;
    }

    // point data
    out << "POINT_DATA " << npts << endl;
    out << "VECTORS dipole float" << endl;
    for (i = 0; i < npts; ++i)
    {
        const sloc::DipoleSource ds = dipole_sources(i);
        dealii::Point<3> p = ds.dipole;
        out << p[0] << " " << p[1] << " " << p[2] << endl;
    }

    // done
    out.close();
}

int main(int argc, char *argv[])
{
    try
    {
        po::options_description desc("Options");
        desc.add_options()
            ("help,h", "produce help message")
            ("vtk,v", po::value<string>(), "output name for vtk file")
            ("output,o", po::value<string>(), "output name of dipoles file")
            ("dipoles,d", po::value<strings>(), "list of dipoles")
            ;

        po::positional_options_description p;
        p.add("dipoles", -1);

        po::variables_map vm;
        po::store(po::command_line_parser(argc, argv).options(desc).positional(p).run(), vm);
        po::notify(vm);

        if (vm.count("help"))
        {
            cout << desc << endl;
            return 0;
        }

        string outputfile;
        if (vm.count("output"))
        {
            outputfile = vm["output"].as<string>();
            //cout << "outputfile = " << outputfile << endl;
        }
        else
        {
            cerr << "Unspecified output file!" << endl;
            return 1;
        }

        string vtkfile;
        if (vm.count("vtk"))
        {
            vtkfile = vm["vtk"].as<string>();
            //cout << "vtkfile = " << vtkfile << endl;
        }

        strings dp;
        if (vm.count("dipoles"))
        {
            dp = vm["dipoles"].as<strings>();
        }
            
        sloc::DipoleSources dipole_sources;
        for (strings::const_iterator it = dp.begin(); it != dp.end(); ++it)
            read_dipole_from_str(dipole_sources, *it);

        dipole_sources.write(outputfile.c_str());
        cout << "Wrote " << outputfile << endl;

        if (vm.count("dipoles"))
        {
            write_vtk_dipoles(dipole_sources, vtkfile.c_str());
            cout << "Wrote " << vtkfile << endl;
        }

    }
    catch (std::exception& exc)
    {
        cerr << "Error: " << exc.what() << endl;
    }
    catch (...)
    {
        cerr << "Exception of unknown type!" << endl;
    }
    return 0;
}
