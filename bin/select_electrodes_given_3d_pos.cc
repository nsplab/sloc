/*
 * Given a mesh and a set of electrode coordinates find the nearest vertex indices, and write out
 * the indices into a file.
 */

#include <iostream>
#include <fstream>
#include <cstring>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <set>
#include <map>
#include <algorithm>
#include <boost/lexical_cast.hpp>
#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/classification.hpp>
#include <boost/smart_ptr.hpp>
#include <getfem/getfem_mesh.h>
#include <sloc/material_data.h>

using namespace std;
using namespace boost::algorithm;

typedef unsigned int id;
typedef map<id,id> map_layers_t;

typedef set<id> set_t;
typedef boost::shared_ptr<set_t> shared_set_t;
typedef map<id,shared_set_t> map_id_set_t;

typedef vector<id> vector_t;
typedef vector<float> vector_f;
typedef boost::shared_ptr<vector_t> shared_vector_t;
typedef map<id,shared_vector_t> map_id_vector_t;

// ----------------------------------------------------------------------------

bool split_coordinate(string str, float &x, float &y, float &z)
{
    vector<string> triple;
    boost::algorithm::split(triple, str, is_any_of("/:"), token_compress_on);

    if (triple.size() != 3)
        return false;

    try {
        x = boost::lexical_cast<float>(triple[0]);
        y = boost::lexical_cast<float>(triple[1]);
        z = boost::lexical_cast<float>(triple[2]);
    } catch (boost::bad_lexical_cast &) {
        return false;
    }

    return true;
}

void write_vtk_points(string filename, getfem::mesh& mesh, map_id_vector_t& nodemap)
{
    int i;
    int npts = 0;

    // how many points do we have?
    for (map_id_vector_t::iterator it = nodemap.begin(); it != nodemap.end(); ++it)
        npts += it->second->size();

    // write out the vtk file
    ofstream out;
    out.open(filename.c_str());
    cout << "Writing vtk file '" << filename << "'" << endl;

    // header
    out << "# vtk DataFile Version 2.0" << endl
        << "Location of electrodes generated by select_electrodes" << endl
        << "ASCII" << endl
        << "DATASET UNSTRUCTURED_GRID" << endl;

    // points
    out << "POINTS " << npts << " float" << endl;
    for (map_id_vector_t::iterator it = nodemap.begin(); it != nodemap.end(); ++it)
    {
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
        {
            const unsigned int n = *vit;
            bgeot::base_node point = mesh.points()[n];
            out << point[0] << " " << point[1] << " " << point[2] << endl;
        }
    }

    // cells
    const int ncells = npts;
    const int size = ncells + 1*ncells;
    out << "CELLS " << ncells << " " << size << endl;
    for (i = 0; i < ncells; i++)
        out << "1 " << i << endl;

    // cell types
    const int VTK_VERTEX = 1;
    out << "CELL_TYPES " << ncells << endl;
    for (i = 0; i < ncells; i++)
        out << VTK_VERTEX << endl;

    // data
    out << "POINT_DATA " << npts << endl;
    out << "SCALARS node_id int 1" << endl;
    out << "LOOKUP_TABLE default" << endl;
    for (map_id_vector_t::iterator it = nodemap.begin(); it != nodemap.end(); ++it)
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
            out << *vit << endl;

    // done
    out.close();
}

// ----------------------------------------------------------------------------

void usage(const char *pgm)
{
    cerr << "Usage: " << pgm
         << " -m meshfile -i matfile [-v vtkfile] -o outfile x1/y1/z1 x2/y2/z2 ..."
         << endl;
    exit(1);
}

void process_args(int argc, char *argv[], string& meshfile, string& matfile, string& vtkfile, string& outfile, vector_f& coordinates)
{
    char *pgm = argv[0];

    if (argc == 1)
        usage(pgm);

    meshfile = "";
    vtkfile = "";
    outfile = "";

    while (argc > 1)
    {
        if (strncmp(argv[1], "-m", 3) == 0)
        {
            // read the next argument (expecting meshfile)
            argc--; argv++;
            if (argc > 1)
                meshfile = argv[1];
            else
                break;
        }
        else if (strncmp(argv[1], "-i", 3) == 0)
        {
            // read the next argument (expecting matfile)
            argc--; argv++;
            if (argc > 1)
                matfile = argv[1];
            else
                break;
        }
        else if (strncmp(argv[1], "-v", 3) == 0)
        {
            // read the next argument (expecting vtkfile)
            argc--; argv++;
            if (argc > 1)
                vtkfile = argv[1];
            else
                break;
        }
        else if (strncmp(argv[1], "-o", 3) == 0)
        {
            // read the next argument (expecting outfile)
            argc--; argv++;
            if (argc > 1)
                outfile = argv[1];
            else
                break;
        }
        else
        {
            // assume it's a coordinate string
            float x, y, z;
            bool valid = split_coordinate(argv[1], x, y, z);

            if (!valid)
            {
                cerr << "Invalid point coordinate '" << argv[1] << "'" << endl;
                usage(pgm);
            }

            coordinates.push_back(x);
            coordinates.push_back(y);
            coordinates.push_back(z);
        }

        // advance to the next argument
        argc--; argv++;
    }

    if (meshfile.empty())
    {
        cerr << "Missing mesh file!" << endl;
        usage(pgm);
    }

    if (outfile.empty())
    {
        cerr << "Missing output file!" << endl;
        usage(pgm);
    }

    /*if (layers.empty())
    {
        cerr << "No layers selected!" << endl;
        usage(pgm);
    }*/
}

// ----------------------------------------------------------------------------

int main(int argc, char *argv[])
{
    // process cli args
    string meshfile, matfile;
    string vtkfile, outfile;
    vector_f coordinates;
    process_args(argc, argv, meshfile, matfile, vtkfile, outfile, coordinates);

    // read the mesh
    getfem::mesh mesh;
    cout << "Reading mesh '" << meshfile << "'" << endl;
    mesh.read_from_file(meshfile.c_str());

    getfem::mesh::PT_TAB pts = mesh.points();
    cout<<"size: "<<pts.size()<<endl;
    cout<<"dim: "<<pts.dim()<<endl;
    getfem::base_node bn(-16.4039, -200.614, -199.513);

    getfem::size_type id = 0;
    //id = pts.search_node(bn, 0.9);
    //id = pts.add_node(bn);
    //cout<<"id: "<<id<<endl;
    //cout<<"pts1: "<<pts[1]<<endl;
    //cout<<"pts10: "<<pts[1][0]<<endl;

    vector<size_t> indices(coordinates.size()/3);
    vector<float> dists(coordinates.size()/3, 10000.0);

    for (size_t i=0; i<pts.size(); i++) {
        for (size_t j=0; j<coordinates.size(); j+=3) {
            float x = coordinates[j] - pts[i][0];
            float y = coordinates[j+1] - pts[i][1];
            float z = coordinates[j+2] - pts[i][2];
            float dist = x*x + y*y + z*z;
            if (dist < dists[j/3]) {
                dists[j/3] = dist;
                indices[j/3] = i;
            }
        }
    }

    ofstream out;
    out.open(outfile.c_str());
    for (size_t i=0; i<indices.size(); i++) {
        cout<<"p1: "<<coordinates[i*3]<<","<<coordinates[i*3+1]<<","<<coordinates[i*3+2]<<endl;
        cout<<"p2: "<<pts[indices[i]]<<endl;
        out<<indices[i]<<endl;
    }
    out.close();

    /*

    // read the mesh materials
    sloc::MaterialData material_data;
    cout << "Reading mesh materials '" << matfile << "'" << endl;
    material_data.read_materials(matfile.c_str());

    // only cells are associated with materials, but we want an association
    // between nodes and material ids. so, we need to walk through each of the
    // cell's nodes and build a map from material ids to its set of nodes
    map_id_set_t nodes_by_mat;
    for (i = 0; i < mesh.nb_convex(); i++)
    {
        const int cell_mat_id = material_data.get_material_id(i);

        if (layers.count(cell_mat_id) > 0)
        {
            if (nodes_by_mat.count(cell_mat_id) == 0)
                nodes_by_mat[cell_mat_id] = shared_set_t(new set_t);

            getfem::mesh::ind_cv_ct pts = mesh.ind_points_of_convex(i);
            for (getfem::mesh::ind_cv_ct::const_iterator it = pts.begin(); it != pts.end(); ++it)
                nodes_by_mat[cell_mat_id]->insert(*it);
        }
    }

    // add up the layer counts
    // (1) only add counts whose layers that are present in the mesh file
    // (2) if desired count is larger than the number of actual nodes in the mesh
    //     by that material id, then use the actual number as the cutoff value
    total_num = 0;
    for (map_layers_t::iterator it = layers.begin(); it != layers.end(); ++it)
    {
        mat = it->first;
        num = it->second;
        if (nodes_by_mat.count(mat) > 0)
        {
            if (num > nodes_by_mat[mat]->size())
                it->second = nodes_by_mat[mat]->size();
            total_num += it->second;
        }
    }

    // now that duplicates are removed, let's copy the sets of nodes
    // into corresponding vectors, so we can shuffle them later
    map_id_vector_t nodes;
    for (map_id_set_t::iterator it = nodes_by_mat.begin(); it != nodes_by_mat.end(); ++it)
    {
        mat = it->first;

        if (nodes.count(mat) == 0)
            nodes[mat] = shared_vector_t(new vector_t);

        for (set_t::iterator sit = it->second->begin(); sit != it->second->end(); ++sit)
            nodes[mat]->push_back(*sit);
    }
    nodes_by_mat.clear();

    // shuffle each of the vectors of nodes and copy the first num elements
    srand(time(NULL));
    map_id_vector_t random_nodes;
    for (map_id_vector_t::iterator it = nodes.begin(); it != nodes.end(); ++it)
    {
        unsigned int mat = it->first;
        unsigned int num = layers[mat];

        //cout << "shuffling layer " << mat << endl;
        random_shuffle(it->second->begin(), it->second->end());

        if (random_nodes.count(mat) == 0)
            random_nodes[mat] = shared_vector_t(new vector_t);

        // copy the first num entries in shuffled vector
        cout << "Taking " << num << " random nodes from layer " << mat << endl;
        unsigned count = 0;
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
        {
            random_nodes[mat]->push_back(*vit);
            if (++count >= num) break;
        }
    }
    nodes.clear();

    // write out the vtk file
    //if (!vtkfile.empty())
    //    write_vtk_points(vtkfile, mesh, random_nodes);

    // write out the electrodes file
    ofstream out;
    out.open(outfile.c_str());
    cout << "Writing " << total_num << " electrodes to '" << outfile << "'" << endl;
    for (map_id_vector_t::iterator it = random_nodes.begin(); it != random_nodes.end(); ++it)
    {
        mat = it->first;
        for (vector_t::iterator vit = it->second->begin(); vit != it->second->end(); ++vit)
        {
            const unsigned int node_id = *vit;
            out << node_id << endl;
        }
    }
    out.close();
    */
    return 0;
}

