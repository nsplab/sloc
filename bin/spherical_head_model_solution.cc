// spherical_head_model_solution.cc
//
// In this file, we seek to compute an approximation to the analytical solution
// to the electric potential field of a current dipole inside a series of
// concentric spherical shells. Conductivity is piecewise constant inside
// each of those layers.
//
// It is important to note that the dipole is assumed to lie within the
// innermost sphere (i.e., the brain).
//
//
// Main papers referenced:
//
// [1] Mosher, J. C., Leahy, R. M., \& Lewis, P. S. (1997).
// Matrix kernels for the forward problem in EEG and MEG.
// Los Alamos National Labs, Tech. Rep. LA-UR-97-3812.
//
// [2] Zhang, Z. (1995).
// A fast method to compute surface potentials generated by dipoles within
// multilayer anisotropic spheres.
// Physics in medicine and biology, 40(3), 335.
//
#include <iostream>
#include <cassert>

#include <boost/math/special_functions/legendre.hpp>
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/io.hpp>
#include <boost/numeric/ublas/assignment.hpp>

using namespace boost::numeric;


// ----------------------------------------------------------------------------

/*
 * Some constants that we can use later
 */

// conductivities in units of S/m
const double sigma_brain = 0.40;
const double sigma_csf = 1.79;
const double sigma_skull = 0.0132;
const double sigma_scalp = 0.275;
const double sigma_air = 3e-15;

// thickness in units of m
const double radius_brain = 70e-3;
const double csf_thickness = 1.5e-3;
const double skull_thickness = 6.5e-3;
const double scalp_thickness = 7e-3;


// ----------------------------------------------------------------------------

/*
 * Definition of spherical head model.
 * TODO: For now, just use global variables. Encapsulate in a proper class later.
 */

// the number of layers to use
const int M = 4;

// shell radii (innermost to outermost)
const double radius[M] = {
    radius_brain,
    radius_brain + csf_thickness,
    radius_brain + csf_thickness + skull_thickness,
    radius_brain + csf_thickness + skull_thickness + scalp_thickness
};

// conductivities of each shell (innermost to outermost)
// TODO: wait a minute..does the paper already assume the outermost layer has
// conductivity of zero? or do we have to list it explicitly
const double sigma[M+1] = {
    sigma_brain,
    sigma_csf,
    sigma_skull,
    sigma_scalp,
    sigma_air
};


// ----------------------------------------------------------------------------

/*
 * Dipole parameters.
 * TODO: Again, use globals for now. Fix later.
 */

// dipole strength (typically scale is in the nAm)
const double dipole[3] = {0, 0, 10e-9};

// location of dipole (in meters)
const double dipole_location[3] = { 10e-3, 11e-3, 12e-2 };


// ----------------------------------------------------------------------------


// There's no cross product defined on ublas::vector<T>, since it only makes
// sense for 3d vectors. So let's make up our own cross product function.
void cross(ublas::vector<double> a, ublas::vector<double> b, ublas::vector<double>& c)
{
    // Basic check
    assert(a.size() == 3);
    assert(b.size() == 3);

    //
    //         | i   j   k  |
    // a x b = | a0  a1  a2 |
    //         | b0  b1  b2 |
    //
    c(0) = +(a(1) * b(2) - b(1) * a(2));
    c(1) = -(a(0) * b(2) - b(0) * a(2));
    c(2) = +(a(0) * b(1) - b(0) * a(1));
}


// calculate one of coefficients in the series
double f(int n)
{
    // we are building a product, so initialize to the identity matrix
    ublas::matrix<double> m(2,2) = ublas::identity_matrix<double>(2);

    // k-th product term
    ublas::matrix<double> m_k(2,2);

    // calculate matrix products.
    // TODO: paper warns that the highest index matrix should be
    // multiplied first... does this mean that we have to instead
    // count down from M-1 all the way down to 0 (as opposed to
    // the usual from 0 to M-1)..
    for (int k = M-1; k >= 0; k++)
    {
        double s_k = sigma[k] / sigma[k+1];
        double r_kn = std::pow(rq / radius[k], 2*n + 1);

        m_k(0,0) = n + (n + 1) * s_k;
        m_k(0,1) = (n + 1) * (s_k - 1) * r_kn;
        m_k(1,0) = n * (s_k - 1) * r_kn;
        m_k(1,1) = (n + 1) + n * s_k;

        // accumulate the product
        // (do this explicitly...the *= operator was ambiguous)
        m = m * m_k;
    }

    m /= std::pow(2*n + 1, M - 1);

    return n / (n * m(1,1) + (1 + n) * m(1,0));
}

double spherical_head_model_potential(double point[3], int numterms)
{
    ublas::vector<double> r(3);
    r <<= point[0], point[1], point[2];

    ublas::vector<double> r_q(3);
    r_q <<= dipole_location[0], dipole_location[1], dipole_location[2];

    ublas::vector<double> q(3);
    q <<= dipole[0], dipole[1], dipole[2];

    // two unit vectors, used for angle calculations
    ublas::vector<double u1(3);
    ublas::vector<double u2(3);

    // alpha is the angle between r_q and dipole moment q.
    // these two vectors define a plane P1.
    u1 = r_q / ublas::norm_2(r_q);
    u2 = q / ublas::norm_2(q);
    double alpha = acos(ublas::inner_prod(u1, u2));
    double cosa = cos(alpha);
    double sina = sin(alpha);

    // gamma is the angle between r_q and the observation point r
    // these two vectors define a plane P2.
    u2 = r / ublas::norm_2(r);
    double gamma = acos(ublas::inner_prod(u1, u2));
    double cosg = cos(gamma);

    // beta is the angle between the planes P1 and P2.
    // I think that's just the angle between the plane normals..
    // Is that correct?
    cross(r_q, q, u1);
    u1 /= ublas::norm_2(u1);
    cross(r_q, r, u2);
    u2 /= ublas::norm_2(u2);
    double beta = acos(ublas::inner_prod(u1, u2));
    double cosb = cos(beta);
    
    // accumulate terms
    const double v = 0.0;

    for (int n = 1; n < numterms; n++)
    {
        double f_n = f(n);
        double r_n = std::pow(r_q / r, n - 1);
        double P_n = boost::math::legendre_p(n, cosg);
        double P_n1 = boost::math:legendre_p(n, 1, cosg);
        v += ((2*n + 1.0) / n) * r_n * f_n * (n * cosb * P_n + cosb * sina * P_n1);
    }

    // TODO: wait a minute..why do we divide by sigma[M] here?
    // the last layer is air, so that would be a division by zero...
    // what is going on?? is it a one-based index thing? (we're using zero-based
    // indices here)...
    const double pi = M_PI;
    const double K = q / (4 * pi * sigma[M]);

    // finalize the computation of the potential at given point
    v *= K / r2;

    return v;
}

// ----------------------------------------------------------------------------

int main(int argc, const char *argv[])
{
    using namespace std;

    // just an example...try loading from file once the rest of this stuff works
    const int npts = 4;
    const double points[3 * npts] {
        0, 0, 0,
        10e-3, 10e-3, 10e-3,
        20e-3, 20e-3, 20e-3,
        30e-3, 30e-3, 30e-3
    };

    // we truncate the infinite series at the N-th term
    // TODO: how many is too many? series might be slow to converge,
    // or it might not. need to check how fast the values computed
    // converge as a function of N.
    int N = 30;

    // write out the potentials to standard output (write to file once it works)
    for (int i = 0; i < npts; i++)
    {
        double *pt = &pt[3*i];
        double v = spherical_head_model_potential(pt, N);
        cout << pt[0] << " " << pt[1] << " " << pt[2] << " " << v << endl;
    }

    return 0;
}
